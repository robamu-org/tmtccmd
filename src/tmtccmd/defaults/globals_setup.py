import argparse
import collections.abc
import pprint
from typing import Union, List

from tmtccmd.com_if.com_if_utilities import determine_com_if
from tmtccmd.config.globals import check_and_set_core_mode_arg, check_and_set_core_com_if_arg, \
    check_and_set_core_service_arg
from tmtccmd.utility.conf_util import print_core_globals
from tmtccmd.config.definitions import CoreGlobalIds, CoreComInterfaces, CoreModeList, \
    CoreServiceList, DEBUG_MODE
from tmtccmd.defaults.com_setup import default_serial_cfg_setup, default_tcpip_udp_cfg_setup
from tmtccmd.core.globals_manager import update_global
from tmtccmd.utility.tmtcc_logger import get_logger
from tmtccmd.ecss.conf import set_default_apid, set_pus_tc_version, set_pus_tm_version, PusVersion

LOGGER = get_logger()


def set_json_cfg_path(json_cfg_path: str):
    update_global(CoreGlobalIds.JSON_CFG_PATH, json_cfg_path)


def set_default_globals_pre_args_parsing(
        gui: bool, apid: int, pus_tc_version: PusVersion = PusVersion.PUS_C,
        pus_tm_version: PusVersion = PusVersion.PUS_C,
        com_if_id: int = CoreComInterfaces.DUMMY, display_mode="long",
        tm_timeout: float = 4.0, print_to_file: bool = True, tc_send_timeout_factor: float = 2.0
):
    update_global(CoreGlobalIds.APID, apid)
    set_default_apid(default_apid=apid)
    set_pus_tc_version(pus_tc_version)
    set_pus_tm_version(pus_tm_version)
    update_global(CoreGlobalIds.COM_IF, com_if_id)
    update_global(CoreGlobalIds.TC_SEND_TIMEOUT_FACTOR, tc_send_timeout_factor)
    update_global(CoreGlobalIds.TM_TIMEOUT, tm_timeout)
    update_global(CoreGlobalIds.DISPLAY_MODE, display_mode)
    update_global(CoreGlobalIds.PRINT_TO_FILE, print_to_file)
    update_global(CoreGlobalIds.SERIAL_CONFIG, dict())
    update_global(CoreGlobalIds.ETHERNET_CONFIG, dict())
    pp = pprint.PrettyPrinter()
    update_global(CoreGlobalIds.PRETTY_PRINTER, pp)
    update_global(CoreGlobalIds.TM_LISTENER_HANDLE, None)
    update_global(CoreGlobalIds.COM_INTERFACE_HANDLE, None)
    update_global(CoreGlobalIds.TMTC_PRINTER_HANDLE, None)
    update_global(CoreGlobalIds.PRINT_RAW_TM, False)
    update_global(CoreGlobalIds.RESEND_TC, False)
    update_global(CoreGlobalIds.OP_CODE, "0")
    update_global(CoreGlobalIds.MODE, CoreModeList.LISTENER_MODE)


def set_default_globals_post_args_parsing(
        args: argparse.Namespace,
        json_cfg_path: str,
        custom_modes_list: Union[None, List[Union[collections.abc.Iterable, dict]]] = None,
        custom_services_list: Union[None, List[Union[collections.abc.Iterable, dict]]] = None,
        custom_com_ifs_lists: Union[None, List[Union[collections.abc.Iterable, dict]]] = None):
    """
    This function takes the argument namespace as a parameter and determines
    a set of globals from the parsed arguments.
    If custom dictionaries are specified, the developer should take care of specifying
    integers as keys and the string representation of the command line argument as value.
    This will be used for internalization.
    :param args:                    Namespace generated by parsing command line arguments.
    :param json_cfg_path:
    :param custom_modes_list:       List of collections or dictionaries containing custom modes
    :param custom_services_list:    List of collections or dictionaries containing custom services
    :param custom_com_ifs_lists:    List of collections or dictionaries containing customcommunication interfaces
    :return:
    """

    # Determine communication interface from arguments. Must be contained in core modes list
    try:
        mode_param = args.mode
    except AttributeError:
        LOGGER.warning("Passed namespace does not contain the mode (-m) argument")
        mode_param = CoreModeList.LISTENER_MODE
    mode_param = check_and_set_core_mode_arg(
        mode_arg=mode_param, custom_modes_list=custom_modes_list
    )

    # Determine communication interface from arguments. Must be contained in core comIF list
    try:
        com_if_param = args.com_if
    except AttributeError:
        LOGGER.warning("No communication interface specified")
        LOGGER.warning("Trying to set from existing configuration..")
        com_if_param = "unspec"
    if com_if_param == "unspec":
        from tmtccmd.config.definitions import CoreComInterfacesString
        LOGGER.info("Communication interface unspecified. "
                    "Trying to read from JSON or prompting from user..")
        com_if_param = determine_com_if(
            integer_to_string_dict=CoreComInterfacesString, json_cfg_path=json_cfg_path
        )
    com_if_param = check_and_set_core_com_if_arg(
        com_if_arg=com_if_param, custom_com_ifs_list=custom_com_ifs_lists
    )

    display_mode_param = "long"
    if args.short_display_mode is not None:
        if args.short_display_mode:
            display_mode_param = "short"
        else:
            display_mode_param = "long"
    update_global(CoreGlobalIds.DISPLAY_MODE, display_mode_param)

    # Determine service from arguments. Must be contained in core service list
    try:
        service_param = args.service
    except AttributeError:
        LOGGER.warning("Passed namespace does not contain the service (-s) argument")
        service_param = CoreServiceList.SERVICE_17
    if isinstance(service_param, str):
        service_param = service_param.lower()
    check_and_set_core_service_arg(
        service_arg=service_param, custom_service_list=custom_services_list
    )

    if args.op_code is None:
        op_code = 0
    else:
        op_code = str(args.op_code).lower()
    update_global(CoreGlobalIds.OP_CODE, op_code)

    try:
        check_and_set_other_args(args=args)
    except AttributeError:
        LOGGER.exception("Passed arguments are missing components.")

    # For a serial communication interface, there are some configuration values like
    # baud rate and serial port which need to be set once but are expected to stay
    # the same for a given machine. Therefore, we use a JSON file to store and extract
    # those values
    if com_if_param == CoreComInterfaces.SERIAL_DLE or \
            com_if_param == CoreComInterfaces.SERIAL_FIXED_FRAME or \
            com_if_param == CoreComInterfaces.SERIAL_QEMU:
        default_serial_cfg_setup(com_if=com_if_param, json_cfg_path=json_cfg_path)

    # Same as above, but for server address and server port
    if com_if_param == CoreComInterfaces.TCPIP_UDP:
        # TODO: Port and IP address can also be passed as CLI parameters.
        #      Use them here if applicable?
        default_tcpip_udp_cfg_setup(json_cfg_path=json_cfg_path)
    if DEBUG_MODE:
        print_core_globals()


def get_core_service_dict() -> dict:
    core_service_dict = dict()
    core_service_dict[CoreServiceList.SERVICE_2] = ["Service 2 Raw Commanding"]
    core_service_dict[CoreServiceList.SERVICE_3] = ["Service 3 Housekeeping"]
    core_service_dict[CoreServiceList.SERVICE_5] = ["Service 5 Event"]
    core_service_dict[CoreServiceList.SERVICE_8] = ["Service 8 Functional Commanding"]
    core_service_dict[CoreServiceList.SERVICE_9] = ["Service 9 Time"]
    core_service_dict[CoreServiceList.SERVICE_11] = ["Service 11 Telecommand Scheduling"]
    core_service_dict[CoreServiceList.SERVICE_17] = ["Service 17 Test"]
    core_service_dict[CoreServiceList.SERVICE_20] = ["Service 20 Parameters"]
    core_service_dict[CoreServiceList.SERVICE_23] = ["Service 23 File Management"]
    core_service_dict[CoreServiceList.SERVICE_200] = ["Service 200 Mode Management"]
    return core_service_dict


def check_and_set_other_args(args):
    if args.listener is not None:
        update_global(CoreGlobalIds.USE_LISTENER_AFTER_OP, args.listener)
    if args.tm_timeout is not None:
        update_global(CoreGlobalIds.TM_TIMEOUT, args.tm_timeout)
    if args.print_hk is not None:
        update_global(CoreGlobalIds.PRINT_HK, args.print_hk)
    if args.print_tm is not None:
        update_global(CoreGlobalIds.PRINT_TM, args.print_tm)
    if args.raw_data_print is not None:
        update_global(CoreGlobalIds.PRINT_RAW_TM, args.raw_data_print)
    if args.print_log is not None:
        update_global(CoreGlobalIds.PRINT_TO_FILE, args.print_log)
    if args.resend_tc is not None:
        update_global(CoreGlobalIds.RESEND_TC, args.resend_tc)
    update_global(CoreGlobalIds.TC_SEND_TIMEOUT_FACTOR, 3)
